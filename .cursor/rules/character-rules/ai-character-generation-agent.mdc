---
description: Generating 3d models
globs: 
alwaysApply: false
---
# AI Character Generation Guidelines

## Photo-to-Model Conversion Process

### Reference Photo Requirements
- **2-3 high-quality photos** minimum per character (front, side, 3/4 view preferred)
- **Well-lit, clear facial features** for accurate anime conversion
- **Neutral expressions** for base model - emotions added through animation
- **Consistent lighting** across all reference photos
- **Store in organized folders**: `Assets/Characters/{StudentName}/Photos/`

### Anime Style Conversion Prompts
```
"Create a 3D anime-style character model based on these reference photos. 
Style requirements:
- Large, expressive eyes with customizable size scaling
- Soft, rounded facial features typical of anime/manga
- Clean, simplified geometry suitable for real-time rendering
- Proportions: slightly larger head, smaller body for cute aesthetic
- Smooth, cartoon-like textures with cell-shading compatibility
- Modular design allowing outfit and accessory attachment points"
```

## Character Customization Architecture

### Scalable Feature System
- **Eye size scaling**: Implement as bone-based scaling system, not mesh deformation
- **Facial expression blendshapes**: Minimum 10 expressions (happy, sad, surprised, etc.)
- **Modular attachment points**: Standardized bones for hats, jewelry, accessories
- **Outfit system**: Separate mesh layers for different clothing categories
- **Hair variations**: Swappable hair meshes with physics-enabled strands

### Technical Implementation
```python
from dataclasses import dataclass
from typing import List, Optional
from bpy.props import FloatProperty

@dataclass
class CharacterCustomization:
    """Character customization data"""
    
    # Facial Features
    eye_size: float = 1.0  # Range: 0.5 to 2.0
    face_width: float = 1.0  # Range: 0.8 to 1.2
    
    # Outfit System
    current_outfit: Optional['OutfitData'] = None
    equipped_accessories: List['AccessoryData'] = None
    
    # Animation
    animator_controller: Optional[str] = None
    expression_blend_speed: float = 2.0
    
    def __post_init__(self):
        if self.equipped_accessories is None:
            self.equipped_accessories = []
```

## Animation Requirements

### Essential Animation Set
- **Dance**: 3-4 variations (simple, energetic, cultural, celebration)
- **Wave**: Standard greeting with hand motion
- **Wai**: Traditional Thai greeting (hands together, bow)
- **Curtsy**: Formal bow with dress/skirt motion
- **Bow**: Respectful Japanese-style bow
- **Idle variations**: 5+ subtle ambient animations

### Animation Guidelines
- **Smooth transitions**: 0.2-0.5 second blend times between animations
- **Loop-friendly**: All animations should loop seamlessly
- **Scalable timing**: Animations adapt to character mood (slower when sad, faster when happy)
- **Cultural sensitivity**: Research proper form for cultural gestures

## Outfit and Accessory System

### Clothing Categories
- **Casual wear**: T-shirts, jeans, everyday clothing
- **Formal wear**: School uniforms, dress clothes, special occasions
- **Cultural outfits**: Traditional Thai clothing, international costumes
- **Seasonal items**: Summer/winter variants, holiday themes
- **Fantasy/costume**: Creative, playful outfit options

### Accessory Types
- **Headwear**: Hats, caps, headbands, traditional headdresses
- **Jewelry**: Necklaces, bracelets, earrings, rings
- **Functional items**: Glasses, bags, shoes, watches
- **Special effects**: Glowing items, animated accessories

### Implementation Structure
```python
import bpy
from dataclasses import dataclass
from typing import List, Optional
from enum import Enum

class OutfitCategory(Enum):
    CASUAL = "casual"
    FORMAL = "formal"
    CULTURAL = "cultural"
    SEASONAL = "seasonal"
    FANTASY = "fantasy"

class OutfitStyle(Enum):
    MODERN = "modern"
    TRADITIONAL = "traditional"
    PLAYFUL = "playful"

@dataclass
class OutfitData:
    """Outfit data configuration"""
    
    # Visual
    icon_path: str = ""
    outfit_blend_file: str = ""
    material_names: List[str] = None
    
    # Gameplay
    coin_cost: int = 0
    gem_cost: int = 0
    requires_achievement: bool = False
    unlock_condition: str = ""
    
    # Categories
    category: OutfitCategory = OutfitCategory.CASUAL
    style: OutfitStyle = OutfitStyle.MODERN
    is_seasonal_item: bool = False
    
    def __post_init__(self):
        if self.material_names is None:
            self.material_names = []
```

## Quality Assurance Standards

### Visual Consistency
- **Unified art style**: All characters should feel like they belong in the same world
- **Consistent proportions**: Maintain anime aesthetic ratios across all models
- **Optimized poly counts**: Target 8-12k polygons for desktop compatibility
- **Texture resolution**: 512x512 for accessories, 1024x1024 for main character
- **Color palette harmony**: Use consistent color schemes across outfits

### Technical Requirements
- **Rigging standards**: Humanoid rig for Blender's animation system
- **Bone hierarchy**: Consistent naming convention for all character bones
- **Physics integration**: Cloth physics for skirts, hair physics for longer styles
- **LOD system**: Multiple detail levels for performance optimization
- **Lighting compatibility**: Models work with both real-time and baked lighting

## Examples

<example>
Proper character generation workflow:
```python
import bpy
from typing import List, Optional
from dataclasses import dataclass

class CharacterGenerator:
    """Character generation manager"""
    
    def __init__(self):
        self.reference_photos: List[str] = []
        self.style_settings: Optional['AnimeStyleSettings'] = None
        self.default_customization: Optional['CustomizationProfile'] = None
    
    async def generate_character_async(self, student_name: str) -> Optional[bpy.types.Object]:
        """Generate character from photos"""
        
        # Load reference photos from student folder
        photo_path = f"Assets/Characters/{student_name}/Photos/"
        photos = self.load_photos_from_directory(photo_path)
        
        # Generate AI prompt with style requirements
        prompt = self.build_anime_style_prompt(photos, self.style_settings)
        
        # Create base character model
        base_model = await self.ai_model_generator.generate_from_prompt(prompt)
        
        # Apply customization systems
        self.setup_customization_rig(base_model)
        self.attach_animation_controller(base_model)
        self.configure_blend_shapes(base_model)
        
        # Save generated character
        character_path = f"Assets/Characters/{student_name}/Models/"
        return self.save_character_asset(base_model, character_path)
    
    def setup_customization_rig(self, character: bpy.types.Object) -> None:
        """Setup customization rig for character"""
        
        # Ensure eye scaling bones are properly configured
        eye_scaler = EyeScalingSystem(character)
        eye_scaler.initialize()
        
        # Setup attachment points for accessories
        attachment_system = AccessoryAttachmentSystem(character)
        attachment_system.configure_attachment_points()
```
</example>

<example type="invalid">
Avoid inflexible character generation:
```python
# ‚ùå DON'T: Rigid, non-scalable approach
class BadCharacterGenerator:
    character_blend_file = "character.blend"  # Single fixed model
    
    def make_character(self):
        # No customization, no photo input, no AI generation
        bpy.ops.wm.open_mainfile(filepath=self.character_blend_file)
```
</example>


