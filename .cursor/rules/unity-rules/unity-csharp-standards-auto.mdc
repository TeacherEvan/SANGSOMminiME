---
description:
globs:
alwaysApply: false
---
---
description: 
globs: *.cs, Assets/**/*.cs
alwaysApply: false
---

# Unity C# Development Standards

## Code Structure Requirements

### Namespace and Class Organization
- **Always use explicit namespaces** following project structure: `SangsomMiniMe.{Folder}.{Subfolder}`
- **Single class per file** with matching filename
- **Use regions** to organize large classes: `#region Public Methods`, `#region Private Fields`

### Unity-Specific Patterns
- **MonoBehaviour lifecycle methods** in standard order: Awake, Start, Update, OnDestroy
- **Serialize fields properly** using `[SerializeField]` instead of public fields
- **Use Unity Events** for loose coupling: `UnityEvent<T>` for typed events
- **Implement IDisposable** for classes managing resources

### Performance and Memory
- **Cache component references** in Awake/Start, not in Update
- **Use object pooling** for frequently instantiated objects
- **Avoid boxing/unboxing** with generics and proper type handling
- **Implement proper null checking** with Unity's null-coalescing operators

## Error Handling and Logging

### Exception Management
```csharp
try
{
    // Risky operation
    characterData = LoadCharacterData(studentId);
}
catch (System.Exception ex)
{
    Debug.LogError($"Failed to load character data for {studentId}: {ex.Message}");
    characterData = CreateDefaultCharacterData(studentId);
}
```

### Debug Logging Standards
- **Use Debug.Log() for development** information
- **Use Debug.LogWarning()** for non-critical issues  
- **Use Debug.LogError()** for critical failures
- **Include context information** in all log messages

## Examples

<example>
Proper Unity C# class structure:
```csharp
using UnityEngine;
using UnityEngine.Events;
using SangsomMiniMe.Character;

namespace SangsomMiniMe.UI
{
    public class CharacterCustomizationUI : MonoBehaviour
    {
        #region Serialized Fields
        [SerializeField] private Slider eyeSizeSlider;
        [SerializeField] private Button[] outfitButtons;
        [SerializeField] private Transform characterPreview;
        #endregion

        #region Events
        [System.Serializable]
        public class CharacterUpdatedEvent : UnityEvent<CharacterData> { }
        public CharacterUpdatedEvent OnCharacterUpdated;
        #endregion

        #region Private Fields
        private CharacterData currentCharacter;
        private CharacterManager characterManager;
        #endregion

        #region Unity Lifecycle
        private void Awake()
        {
            characterManager = FindObjectOfType<CharacterManager>();
        }

        private void Start()
        {
            InitializeUI();
        }

        private void OnDestroy()
        {
            eyeSizeSlider?.onValueChanged.RemoveAllListeners();
        }
        #endregion

        #region Public Methods
        public void UpdateCharacter(CharacterData newData)
        {
            currentCharacter = newData ?? throw new System.ArgumentNullException(nameof(newData));
            RefreshUI();
            OnCharacterUpdated?.Invoke(currentCharacter);
        }
        #endregion

        #region Private Methods
        private void InitializeUI()
        {
            eyeSizeSlider.onValueChanged.AddListener(OnEyeSizeChanged);
            SetupOutfitButtons();
        }

        private void OnEyeSizeChanged(float value)
        {
            if (currentCharacter != null)
            {
                currentCharacter.EyeSize = Mathf.Clamp01(value);
                characterManager.UpdateCharacterVisuals(currentCharacter);
            }
        }
        #endregion
    }
}
```
</example>

<example type="invalid">
Avoid poor Unity C# practices:
```csharp
// ‚ùå DON'T: Bad Unity practices
public class BadCharacterScript : MonoBehaviour 
{
    public float eyeSize; // Public field instead of SerializeField
    GameObject character; // Missing Component caching
    
    void Update() 
    {
        // Finding components in Update - performance killer
        character = GameObject.Find("Character");
        
        // No error handling
        character.transform.localScale = Vector3.one * eyeSize;
    }
}
```
</example>
